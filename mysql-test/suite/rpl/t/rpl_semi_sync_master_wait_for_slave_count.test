--echo # MDEV-18983: `@@rpl_semi_sync_master_wait_for_slave_count` feature test
# A gotcha: The FLUSH GLOBAL STATUS statments in this test are also replicated.

--source include/have_debug.inc
--source include/have_debug_sync.inc
--source include/have_binlog_format_mixed.inc # format-agnostic
# The variable's default is 1 to match the behavior before this feature came.
# Therefore, this test uses two slaves to prove that the variable took effect.
--let $rpl_topology= 1->2, 1->3
--source include/rpl_init.inc

SET @dbug_reset= @@GLOBAL.debug_dbug;


--echo # Case 0: Semi-Sync commits only when both slaves ACKs
# Simulate lag on one of the replicas
--connection server_3
SET @dbug_reset= @@GLOBAL.debug_dbug;
SET @@GLOBAL.debug_dbug= '+d,simulate_delay_semisync_slave_reply';

# Send two transactions concurrently
--connection server_1
SET @@GLOBAL.debug_dbug= '+d,sync_semisync_report_reply';
# Case 2.1 explicitly tests for a timeout, but this warning is also replicated
--send CALL mtr.add_suppression('Timeout waiting for reply of binlog')
--connection default
SET @@SESSION.debug_sync= 'now WAIT_FOR report_reply_wait';
SET @@GLOBAL.debug_dbug= @dbug_reset;
SET @@SESSION.debug_sync= 'now SIGNAL report_reply_continue';

# Check status mid-transaction - expect 0 while waiting for the "slow" slave
SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_%\_tx';
SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_get\_ack'; # TEMP

# Begin the other transaction
--send CREATE TABLE t (a INT)

# Unblock the first transcation
--connection server_3
SET @@SESSION.debug_sync= 'now SIGNAL io_thd_do_reply';

# Check status between transactions - expect 1 for the first transaction only
--connection server_1
--reap
SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_%\_tx';
SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_get\_ack'; # TEMP

# Unblock the other transcation
--connection server_3
SET @@GLOBAL.debug_dbug= @dbug_reset; # (and all future transactions)
SET @@SESSION.debug_sync= 'now SIGNAL io_thd_do_reply';
--connection server_1
--connection default
--reap

# Check status in full after transactions - expect 2 successful transactions
SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_%\_tx';
SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_get\_ack';
--connection server_2
SHOW STATUS LIKE 'Rpl\_semi\_sync\_slave\_send\_ack';
--connection server_3
SHOW STATUS LIKE 'Rpl\_semi\_sync\_slave\_send\_ack';
--connection server_1

--echo # Case 1: Lowering a high requirement unblocks the waiting Semi-Sync
SET @@GLOBAL.rpl_semi_sync_master_wait_for_slave_count= 3;
SET @@GLOBAL.debug_dbug= '+d,sync_semisync_report_reply';
--send FLUSH GLOBAL STATUS
--connection default
# Wait for 2 *complete* ACK processings
SET @@SESSION.debug_sync= 'now WAIT_FOR report_reply_wait';
SET @@SESSION.debug_sync=
  'now SIGNAL report_reply_continue WAIT_FOR report_reply_wait';
SET @@GLOBAL.debug_dbug= @dbug_reset;
SET @@SESSION.debug_sync= 'now SIGNAL report_reply_continue';
SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_%\_tx'; # expect 0
SET @@GLOBAL.rpl_semi_sync_master_wait_for_slave_count= 2;
--connection server_1
--reap
SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_%\_tx';


--let $wait_no_slave= 0
while ($wait_no_slave < 2)
{
  --echo # Cases 2.x Matrix:
  --eval SET @@GLOBAL.rpl_semi_sync_master_wait_no_slave= $wait_no_slave

  --echo # Case 2.1: falls back to Async when the requirement is set too high
  SET @@GLOBAL.rpl_semi_sync_master_wait_for_slave_count= 3;
  FLUSH GLOBAL STATUS;
  SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_%\_tx';

  if ($wait_no_slave)
  {
    --echo # Case 2.2: Semi-Sync stays timed-out on an up-to-date reconnect
    SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_status';
    --connection server_3
    --source include/stop_slave.inc
    --source include/start_slave.inc
    --connection server_1
    SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_status';
  }

  --echo # Case 2.3: stays Async as long as the requirement is not met
  SET @@GLOBAL.debug_dbug= '+d,sync_semisync_report_reply';
  --eval INSERT INTO t VALUES (3$wait_no_slave) # ask for ACK(s)
  SET @@SESSION.debug_sync= 'now WAIT_FOR report_reply_wait';
  SET @@GLOBAL.debug_dbug= @dbug_reset;
  SET @@SESSION.debug_sync= 'now SIGNAL report_reply_continue';
  FLUSH GLOBAL STATUS; # check a new transaction
  SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_%\_tx';

  --echo # Case 2.4: returns to Semi-Sync when the requirement is set just right
  SET @@GLOBAL.rpl_semi_sync_master_wait_for_slave_count= 2;
  SET @@GLOBAL.debug_dbug= '+d,sync_semisync_report_reply';
  --eval INSERT INTO t VALUES (4$wait_no_slave) # ask for ACK(s)
  # Wait for 2 *complete* ACK processings
  SET @@SESSION.debug_sync= 'now WAIT_FOR report_reply_wait';
  SET @@SESSION.debug_sync=
    'now SIGNAL report_reply_continue WAIT_FOR report_reply_wait';
  SET @@GLOBAL.debug_dbug= @dbug_reset;
  SET @@SESSION.debug_sync= 'now SIGNAL report_reply_continue';
  FLUSH GLOBAL STATUS; # check a new transaction
  SHOW STATUS LIKE 'Rpl\_semi\_sync\_master\_%\_tx';

  --inc $wait_no_slave
}


--echo # Cleanup
SET @@GLOBAL.debug_dbug= @dbug_reset;
SET @@SESSION.debug_sync= 'RESET';
DROP TABLE t;
--source include/rpl_end.inc
